# Section 21.1 Linux Compatible Layer

Note**
>
>A common misunderstanding is to use the Linux Compatibility layer of FreeBSD as a virtual machine, which is considered to reduce the efficiency of software operations. The reality is that not only will it not be slow, but some software will run faster and more efficiently than in Linux. Because he's not a simulator, not a translation, but Linux ABI。

<https://cgit.freebsd.org/src/tree/sys/compat/linux/linux_file.c>

It's not hard to see from here. There's only one thing to do: identify Linux calls, and then find the corresponding FreeBSD calls. Put the original Linux syscall on the way to the entrance to FreeBSD syscall。

What's Linuxulator

Since we're talking about FreeBSD compatible Linux applications, we're gonna start with Linuxluator. Linuxulator means Linux Emulator -- it's easy to imagine that this is Linux simulator. Linuxulator, however, is not a traditional simulator and does not even have a FreeBSD application with a single executable. Linuxulator is just a popular name for a FreeBSD kernel module in the FreeBSD official document, which is called ___CODESPAN_0_。

TAKE A LOOK AT THE PAGE OF CODESPAN_0_ OF THIS KERNEL MODULE。

# # man page

```sh
$ man 4 linux
```

THE OUTPUT OF __CODESPAN_0_ IS TRANSLATED AS FOLLOWS:

---|---

**LINUX(4)** FreeBSD kernel interface manual**LINUX(4)**

** Name**
linux – Linux ABI support

** Introduction**
To enable Linux ABI on startup, add the following row to __CODESPAN_0:

```sh
linux_enable="YES"
```

** Description**
The Linux kernel module provides limited Linux ABI compatibility, allowing many unmodified Linux applications to run without virtualization and simulation. Some of the functions provided include:

- Linux to the primary system
- Linux-specific system call
- Special signal processing for Linux processes
- Path conversion mechanism
- Linux-specific virtual file system

     路径转换机制使得 Linux 进程在查找文件路径时，会首先在 `emul_path`（默认为 `/compat/linux`）下查找，然后才是 `/`。例如，当一个 Linux 进程尝试打开 `/etc/passwd` 时，它会首先访问 `/compat/linux/etc/passwd`，如果兼容路径不存在，则回退到 `/etc/passwd`。此机制确保 Linux 进程加载的是 Linux 共享库，而非它们对应的 FreeBSD 版本，并且为某些其他文件和虚拟文件系统提供替代版本。

     要将 Linux 共享库和系统文件安装到 `/compat/linux`，可以使用 Port `emulators/linux_base-c7` 或包，或者从 `sysutils/debootstrap` 安装 `debootstrap(8)`。

     为避免在启动时挂载 Linux 特有的文件系统，可以在 `rc.conf(5)` 文件中添加以下行：

```sh
linux_mounts_enable="NO"
```

** SYSCTL VARIABLE**
THE FOLLOWING VARIABLES CAN BE USED EITHER AS __CODESPAN_0 OR AS __CODESPAN_1-MODIFIABLE PARAMETERS:

- CODESPAN_0_
ENABLES DEBUG MESSAGES. SET TO __CODESPAN_0_ SILENT. DEFAULT IS __CODESPAN_1_. PRINT DEBUG MESSAGES WHEN __CODESPAN_2_ IS SET TO REPORT AN UNREALIZED FEATURE (ONLY ONCE). SETS TO __CODESPAN_3 TO BE SIMILAR TO __CODESPAN_4, BUT ALSO TO PRINT MESSAGES (ONLY ONCE) OF FUNCTIONS PERFORMED BUT NOT TESTED. SET TO __CODESPAN_5 AND ABOVE, SIMILAR TO __CODESPAN_6_, BUT WITH NO INFORMATION FREQUENCY LIMIT。

- CODESPAN_0_
The default soft open file resource limit for Linux applications. Set __CODESPAN_0_ to disable the limit. Default is __CODESPAN_1_。

- CODESPAN_0_
Path to Linux running the environment. Default is __CODESPAN_0_。

- CODESPAN_0_
Name of Linux kernel operating system. Default is "Linux"。

- CODESPAN_0_
The Linux kernel operating system release version. It is not recommended to modify this value on non-developed systems, as this may affect the way Linux programs work. Some versions of GNU libc are known to use different systems depending on the value。

- CODESPAN_0_
Linux Open Audio System version. Default is __CODESPAN_0_。

- CODESPAN_0_
Set to 1 to prevent the Linux application from resetting the VSTATUS settings of __CODESPAN_0_. From a user point of view, this makes __CODESPAN_1_ valid for Linux executable files. Default is __CODESPAN_2_。

- CODESPAN_0_
Enables user ID and group ID settings (set-user-ID and set-group-ID) to process new process mirror files. When set to 0, the new Linux mirror always uses the __CODESPAN_0_caller voucher, ignoring the mirror file mode. Because FreeBSD does not have a complete simulation of Linux environment, the missing functionality could lead to a security gap. Default is __CODESPAN_1_。

     `compat.linux32.emulate_i386`
             在 x86_64（amd64）环境中启用真实的 i386 Linuxulator 行为。例如，当设置为 `0` 时，即使 `uname` 是 i386 Linux 可执行文件，`uname -m` 也会返回 "x86_64"。当设置为 `1` 时，Linux i386 `uname -m` 会返回 "i686"。默认为 `0`。

** Documentation**
__CODESPAN_0_Linux Runtime Environment
__CODESPAN_0_ DEVICE FILE SYSTEM, SEE __CODESPAN_1_
__CODESPAN_0_FILE DESCRIPTOR SYSTEM, WITH __CODESPAN_1_PACKET, SEE __CODESPAN_2_
__CODESPAN_0_MEMORY FILE SYSTEM, SEE __CODESPAN_1_
__CODESPAN_0_Linux Process File System, see __CODESPAN_1_
__CODESPAN_0_Linux kernel object file system, see __CODESPAN_1_

** See **
___ CODESPAN_0, __ CODESPAN_1 , __ CODESPAN_2 , __ CODESPAN_3 , __ CODESPAN_4 , __ CODESPAN_5 ,
_CODESPAN_0_

History**
Linux ABI supports the first appearance in FreeBSD 2.1. Support for the amd64 binary document appears for the first time in FreeBSSD 10.3. Support for the arm64 binary file appears for the first time in FreeBSD 12.0。

**BUG**
Support for certain Linux-specific system calls and system calls parameters is still missing。

FreeBSD 14.2-RELEASE 2022 9 January

---|---

What is this concept? So Linuxulator is neither a WSL2 shell virtual machine, nor an WINE interpretation enforcement. The rationale is that the system call request for the FreeBSD kernel to identify and capture the Linux process, to find the system call for FreeBSD, and to use the system call for FreeBSD kernel to respond to the Linux request。

Note**
>
> ** Linuxulator is a system call from FreeBSD to respond to Linux process system call requests**。

In other words, with Linuxulator's kernel module, the FreeBSD kernel can disguise itself as a Linux kernel, but in fact the Linux process is still being run by the FreeBSD kernel, and processing the Linux system is still the code in the FreeBSD kernel. And from the perspective of the FreeBSD kernel, the Linux and FreeBSD processes run through Linuxulator ** do not differ in substance**. The Linux process is the FreeBSD process。

# What's a Linux Compatible Layer

The path conversion mechanism allows the Linux process to search for a file path under __CODESPAN_1 (default __CODESPAN_2_) before __CODESPAN_0_. For example, when the Linux process tries to open ___CODESPAN_3... it will actually visit __CODESPAN_4... unless the latter does not exist. This is used to ensure that the Linux process loads the Linux shared library, instead of the FreeBSD counterpart library with a similar name, and provides an alternative version of some other documents and virtual file systems。

# Extraterrestrial: Why use Linux Compatibility is not the philosophy of suffering

CODESPAN_0, CODESPAN_1 __ should not be blamed and sarcastic, even though Zilong used to say, “A man is born, a man is born, a man is false.” The same applies to the Linux Compatibility Layer. There is nothing ridiculous about this, but similar technologies like the Win/Crossover (and even [ReactOS] (https://reactos.org/)); the Linux and Android interfaces on Windows are popular。

