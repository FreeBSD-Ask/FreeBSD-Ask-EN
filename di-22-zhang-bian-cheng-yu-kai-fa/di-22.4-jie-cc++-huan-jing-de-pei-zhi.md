# Section 22.4 C/C++ Environment Configuration

# General

FreeBSD Basic System sets the Clang compiler, but does not contain other components of llvm, such as clangd (language server, for code completion, error of compilation, definition of jump, etc.), Clang-Tidy (code style diagnostic) clang-format (for formatting language code).

So to install llvm, all the llvm versions are available, but at least not lower than the clang version of the system, which is 18 in FreeBSD 14.2.

- View clang version:

````
Clang-v
FreeBSD clang version 18.1.6 (https://github.com/llvm/llvm-project.git llvmorg-18.1.6-0-g1118c2e05e67)
Target: x86_64-unknown-freebsd14.2
Thread model:
InstalledDir: /usr/bin
````

llvm20 is used below and the corresponding program after installation is called clang20, clang+20, clangd20, clang-format20. In the basic system, the clang is called `clang ' . If different versions are used, note the contrast.

# Install Clang Environmental Package

- Install with pkg:

```sh '
# pkg install llvm20 and make #
````

- Or install with Ports:

````
#cd /usr/ports/devel/llvm20/ & make install clean
# cd /usr/ports/devel/cmake/ & make install clean
#cd /usr/ports/devel/git/ & make install clean
````

# Configure vim

# # Install vim and plugin manager

- Install with pkg:

```sh '
# Pkg install vim
````

- Or install with Ports:

````
#cd/usr/ports/editos/vim/
# Make install clean
````

I don't...

Installs a vim plugin manager. If you use another plugin manager, adjust yourself:

```sh '
$ mkdir-p ~/.vim/autoload
$ Fetch-o ~/.vim/autoload/plug.vim https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
````

## coc. nvim Add clangd completion

Coc.nvim is a smart completion plugin based on NodeJS for Vim, Neovim. Full LSP support. Configure how to use and the overall style of the plugin system is similar to VSCode. lSP for c/c++.

Install coc.nvim dependent

```sh '
# pkg install npm
````

Or...

```sh '
#cd/usr/ports/www/npm/
# Make install clean
````

Where node is automatically installed as a dependency.

Write in ~/.vimrc '

```sh '
Call pug#begin ('~/.vim/plugged')
Plug 'neocide/coc.nvim',
Call pug#end()
````

Enter `vim ' , enter:

```sh '
Photo by PlugInstall
````

Plugin installation completed and continues in vim with json clangd cmake completion plugins:

```sh '
_Other Organiser
````

Configure clangd completion in vim:

```sh '
Photo by CocConfig
````

After opening the profile, enter and save (you can also manually edit ~/.vim/ coc-sets.json ' for writing):

```sh '
_Other Organiser
"clangd.path": "clangd20."
♪ I'm sorry ♪
````

It's time to use coc to come in and finish.

I don't...

For simple applets, create a new `compile_flags.txt ' file in the source directory, enter:

```sh '
-I/usr/local/include
````

This can be completed in coc with the header under `/usr/local/include ' .

For complex items, complete with `compile_committees.json ' file settings. clangd will be found in your file's parent directory, and also in the subdirectories named Build/. For example, `$SRC/gui/window.cpp ' is being edited to find `$SRC/gui/`, `$SRC/gui/build/`, `$SRC/`, `$SRC/build/ ' etc.

Take CMake-based projects, for example, in project folders

Project structure as shown below

![.. .gitbook/assets/ccenv1.png]

```sh '
$Mkdir built
$cd built
And make-DCMAKE_EXPORT_COMPILE_COMMANDS=1...
````

Or in `CMakeLists.txt '

```sh '
set (CMAKE_EXPORT_COMPILE_COMANDS ON)
````

The `compile_compands.json ' file is automatically generated and can be completed with this file re-editing the source file.

cmake defaults on the clang of the system.

```sh '
US$$export CC=clang20
$export CXX=clang+20
````

`cmake ' to use clang20.

It can be written in documents such as `.xprofile ' :

```sh '
This post is part of our special coverage Syria Protests 2011.
Export CXX=clang+20
````

To make clang20, clang+20 a default, this should be done according to project requirements.

![..gitbook/assets/ccenv2.png]

`compile_committees.json 'files are generated at this time and can be completed in vim

![..gitbook/assets/ccenv3.png]

Note**
>
>The following operation is used in s/bash/zsh, csh/tcsh

# The code is beautiful #

vim-clang-format has not been updated for many years. Therefore, there is a problem with new clang-format support (clang-format15 version normal, clang-format17 and clang-format19) and it is recommended to use vim-codefmt.

## vim-codefmt

Add the following to ~/.vimrc:

````
Plug 'google/vim-maktaba'
Plug 'google/vim-codefmt'
Plug 'google/vim-glaive'
````

Also set in ~/.vimrc ' as follows:

```sh '
#Install()

Glaive codefmt clang_format_exactable=/usr/local/bin/clang-format19
"BasedOnStyle: LLVM, IndentWidth: 4"

Autoformat_settings
Autocmd FileType c,cpp AutoFormatBuffer clang-format
*.h.hpp,*.c,*.cpp:FormatCode
END
````

- First sentence Gloive statement settings to set the path to the clang-format execution file.
- Second sentence Gloive statement sets formatted style styles. It may also be set as `file' or `file: <format_file_path> ' . References [Forms] (https://clang.llvm.org/docs/ClangFormatStyleOptions.html)
- The first sentence automcmd is set to enable the autoFormatBuffer clang-format when the file type is c/cpp.
- Second sentence autocmd to execute the `:FormatCode ' command when suffixed to `.h, .hpp, .c, .cpp '.

I don't...

Save after ~/.vimrc '

```sh '
Photo by PlugInstall
````

You can now format automatically after the exit insert mode or manually perform the `:FormatCode ' command in the vim

# # vim-clang-format

clang-format code beautification by installing a vim-clang-format plugin as follows:

Add ~/.vimrc '

```s 'h
Plug 'rhysd/vim-clang-format'
````

and set in ~/.vimrc '

```sh '
#Code #style
#Command
Let g: clang_format#auto_format=1
=1
````

Save after ~/.vimrc '

```sh '
Photo by PlugInstall
````

This plugin can be used with the following:

![..gitbook/assets/ccenv4.png]

Exit Insert Mode

![..gitbook/assets/ccenv5.png]

# asyncasks.vim Build Task System

Asynctasks.vim plugins introduce vscode-like tasks task systems for Vim, which are systematized in a uniform manner to address all types of tasks: compile/ run/test/deploy.

Install Plugins

```sh '
Plug 'skywind 30000/asyncasks.vim'
Plug 'skywind 30000/asyncrun.vim'
````

Set in ~/.vimrc '

```sh '
Let g: asyncrun_open =6
Let g: asyncrun_rootmarks = ['.get', '.svn', '.root', '.project']
````

of which asyncrun_rootmarks is used to specify files/folders for tagging the root directory of the item

Asynctasks.vim places a `.tasks ' under each project ' s root folder to describe a local task for the project, while maintaining a global task profile of ~/.vim/tasks.ini ' , suitable for some highly generic projects and avoiding the repetition of `.tasks ' configurations for each project.

vim can edit local tasks with `:AsyncTaskEdit ', `:AsyncTaskEdit! ' to edit global tasks.

Like

```sh '
[project-build]
Common=cd built & cmake . & make
# Set to run the root directory of the current item make
cwd=$(VIM_ROOT)

[project-run]
Photo courtesy of Src/test
It's an alias for...
cwd = root
````

References:

- [asyncasks.vim - Modern Build Task System] (https://github.com/skywind30000/asyncasks.vim/blob/master/README-cn.md)

Finally, for example, the simplest C++ hello world project

The project document is structured as follows:

```sh '
/home/j/project/CMakeLists.txt
/home/j/project/src/CMakeLists.txt
/home/j/project/src/main.cpp
/home/j/project/build/
````

- `/home/j/project/CMakeLists.txt ' files

```cpp '
andake_minimum_required
project(test)

set (CMAKE_EXPORT_COMPILE_COMANDS ON)

Include_directors (/usr/local/include)

Add_subdirectory(src)
````

- `/home/j/project/src/CMakeLists.txt ' files

```sh '
edd_executeable
````

- `/home/j/project/src/main.cpp '

```cpp '
#Include #iostream

{std:: cout < "hello world " < std:endl;}
````

Compile Run

```sh '
$cd/home/j/project/build
And make...
````

Generate program file `/home/j/project/build/src/test ', running

![..gitbook/assets/ccenv6.png]

Or run `:AsyncTask project-build ', `:AsyncTask project-run ':

![.. ..gitbook/assets/ccenv7.png]

![.. .gitbook/assets/ccenv8.png]

# Resources

- [algcl] (https://github.com/Jianping-Duan/algcl), examples of C language algorithms and data structure programming that can be directly run on FreeBSD.

。