# SECTION 22.4 C/C++ ENVIRONMENT CONFIGURATION

# General

FreeBSD Basic System sets the Clang compiler, but does not contain other components of llvm, such as clangd (language server, for code completion, error of compilation, definition of jump, etc.), Clang-Tidy (code style diagnostic) clang-format (for formatting language code)。

So to install llvm, all the llvm versions are available, but at least not lower than the clang version of the system, which is 18 in FreeBSD 14.2。

- view clang version:

```
# clang -v
FreeBSD clang version 18.1.6 (https://github.com/llvm/llvm-project.git llvmorg-18.1.6-0-g1118c2e05e67)
Target: x86_64-unknown-freebsd14.2
Thread model: posix
InstalledDir: /usr/bin
```

llvm20 is used below and the corresponding program after installation is called clang20, clang+20, clangd20, clang-format20. And the clang in the basic system, the program is called ___CODESPAN_0_. If different versions are used, note the contrast。

# Install Clang Environmental Package

- install with pkg:

```sh
# pkg install llvm20 cmake git
```

- Or install with Ports:

```
# cd /usr/ports/devel/llvm20/ && make install clean
# cd /usr/ports/devel/cmake/ && make install clean
# cd /usr/ports/devel/git/ && make install clean
```

# configure vim

# # install vim and plugin manager

- install with pkg:

```sh
# pkg install vim
```

- Or install with Ports:

```
# cd /usr/ports/editors/vim/ 
# make install clean
```

---|---

installs a vim plugin manager. if you use another plugin manager, adjust yourself:

```sh
$ mkdir -p ~/.vim/autoload
$ fetch -o ~/.vim/autoload/plug.vim https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```

## coc. nvim add clangd completion

Coc.nvim is a smart completion plugin based on NodeJS for Vim, Neovim. Full LSP support. Configure how to use and the overall style of the plugin system is similar to VSCode. lSP for c/c++。

install coc.nvim dependent

```sh
# pkg install npm
```

Or..

```sh
# cd /usr/ports/www/npm/ 
# make install clean
```

where node is automatically installed as a dependency。

WRITE IN __CODESPAN_0_

```sh
call plug#begin('~/.vim/plugged')
Plug 'neoclide/coc.nvim',{'branch':'release'}
call plug#end()
```

ENTER __CODESPAN_0_, ENTER:

```sh
:PlugInstall
```

plugin installation completed and continues in vim with json clangd cmake completion plugins:

```sh
:CocInstall coc-json coc-clangd coc-cmake
```

configure clangd completion in vim:

```sh
:CocConfig
```

AFTER OPENING THE PROFILE, ENTER AND SAVE (YOU CAN ALSO MANUALLY EDIT `~/.vim/coc-settings.json` WRITING):

```sh
{
	"clangd.path":"clangd20"
}
```

it's time to use coc to come in and finish。

---|---

FOR SIMPLE APPLETS, CREATE A NEW __CODESPAN_0_ FILE UNDER THE SOURCE DIRECTORY, ENTER:

```sh
-I/usr/local/include
```

This can be completed in coc with the header under __CODESPAN_0_。

For complex items, complete with __CODESPAN_0_ files. clangd will be found in your file's parent directory, and also in the subdirectories named Build/. For example, ___ CODESPAN_1 is being edited to find __ CODESPAN_2_, __ CODESPAN_3_, __ CODESPAN_4_, __ CODESPAN_5_, etc

Take CMake-based projects, for example, in project folders

Project structure as shown below

![.. .gitbook/assets/ccenv1.png]

```sh
$ mkdir build
$ cd build
$ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ..
```

OR IN __CODESPAN_0_

```sh
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
```

THE __CODESPAN_0_ FILE CAN BE AUTOMATICALLY GENERATED AND CAN BE USED TO RE-EDIT THE SOURCE FILE。

cmake defaults on the clang of the system

```sh
$ export CC=clang20
$ export CXX=clang++20
```

__CODESPAN_0_for use clang20。

IT CAN BE WRITTEN IN DOCUMENTS SUCH AS __CODESPAN_0:

```sh
export CC=clang20
export CXX=clang++20
```

to make clang20, clang+20 a default, this should be done according to project requirements。

![..gitbook/assets/ccenv2.png]

__CODESPAN_0_file is generated at this time and can be completed in vim

![..gitbook/assets/ccenv3.png]

Note**
>
>the following operation is used in s/bash/zsh, csh/tcsh

# The code is beautiful #

vim-clang-format has not been updated for many years. therefore, there is a problem with new clang-format support (clang-format15 version normal, clang-format17 and clang-format19) and it is recommended to use vim-codefmt。

## vim-codefmt

_CODESPAN_0_ ADD:

```
 Plug 'google/vim-maktaba'
 Plug 'google/vim-codefmt'
 Plug 'google/vim-glaive'
```

ALSO SET IN __CODESPAN_0_ AS FOLLOWS:

```sh
call glaive#Install()

Glaive codefmt clang_format_exactable=/usr/local/bin/clang-format19
"BasedOnStyle: LLVM, IndentWidth: 4"

autoformat_settings
autocmd FileType c,cpp AutoFormatBuffer clang-format
*.h.hpp,*.c,*.cpp:FormatCode
eND
````

- First sentence Gloive statement settings to set the path to the clang-format execution file。
- Second sentence Gloive statement sets formatted style styles. It can also be set as __CODESPAN_0 or `"file:<format_file_path>"`_. References [Format] (https://clang.llvm.org/docs/ClangFormatStyleOptions.html)
- The first sentence automcmd is set to enable the autoFormatBuffer clang-format when the file type is c/cpp。
- The second sentence autocmd is set to execute the __CODESPAN_1_... command when __CODESPAN_0_is suffixed in the file。

---|---

SAVE __CODESPAN_0_ AFTER

```sh
:PlugInstall
```

It is now possible to format __CODESPAN_0_in vim manually after the exit insert mode

# # vim-clang-format

clang-format code beautification by installing a vim-clang-format plugin as follows:

ADD __CODESPAN_0_

```sh
Plug 'rhysd/vim-clang-format'
```

AND SET IN __CODESPAN_0_

```sh
let g:clang_format#code_style="google"
let g:clang_format#command="clang-format15"
let g:clang_format#auto_format=1
let g:clang_format#auto_format_on_insert_leave=1
```

SAVE __CODESPAN_0_ AFTER

```sh
:PlugInstall
```

This plugin can be used with the following:

![..gitbook/assets/ccenv4.png]

Exit Insert Mode

![..gitbook/assets/ccenv5.png]

# asyncasks.vim build task system

asynctasks.vim plugins introduce vscode-like tasks task systems for Vim, which are systematized in a uniform manner to address all types of tasks: compile/ run/test/deploy。

Install Plugins

```sh
Plug 'skywind3000/asynctasks.vim'
Plug 'skywind3000/asyncrun.vim'
```

SET IN __CODESPAN_0_

```sh
let g:asyncrun_open = 6
let g:asyncrun_rootmarks = ['.git', '.svn', '.root', '.project']
```

of which asyncrun_rootmarks is used to specify files/folders for tagging the root directory of the item

asynctasks.vim places a __CODESPAN_0_ under each project's root folder to describe a local task for the project, while maintaining a global task configuration of __CODESPAN_1_, suitable for some highly generic projects and avoiding rewriting __CODESPAN_2_ for each project。

vim can edit local tasks by __CODESPAN_0, __CODESPAN_1_。

Like

```sh
[project-build]
command=cd build && cmake .. && make
# 设置在当前项目的根目录处运行 make
cwd=$(VIM_ROOT)

[project-run]
photo courtesy of src/test
It's an alias for..
cwd = root
````

References:

- [asyncasks.vim - Modern built task system] (https://github.com/skywind30000/asyncasks.vim/blob/master/REDME-cn.md)

Finally, for example, the simplest C++ hello world project

The project document is structured as follows:

```sh
/home/j/project/CMakeLists.txt
/home/j/project/src/CMakeLists.txt
/home/j/project/src/main.cpp
/home/j/project/build/
```

-_CODESPAN_0_FILE

```cpp
cmake_minimum_required(VERSION 3.10)
project(test)

set (CMAKE_EXPORT_COMPILE_COMANDS ON)

include_directors (/usr/local/include)

add_subdirectory(src)
````

-_CODESPAN_0_FILE

```sh
add_executable(test main.cpp)
```

-_CODESPAN_0_FILE

```cpp
#include <iostream>

{std:: cout < "hello world " < std:endl;}
````

Compile Run

```sh
$ cd /home/j/project/build
$ cmake ..
```

GENERATE PROGRAM FILE __CODESPAN_0_, RUN

![..gitbook/assets/ccenv6.png]

Or run __CODESPAN_0, __CODESPAN_1_:

![.. ..gitbook/assets/ccenv7.png]

![.. .gitbook/assets/ccenv8.png]

# Resources

- [algcl] (https://github.com/Jianping-Duan/algcl), examples of C language algorithms and data structure programming that can be directly run on FreeBSD。

