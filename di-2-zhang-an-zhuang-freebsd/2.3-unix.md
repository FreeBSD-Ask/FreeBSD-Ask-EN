SECTION 2.3 UNIX FOUNDATION (NEW INTRODUCTORY VERSION)

# The difference between the UNIX directory and the Windows directory

First of all, we appreciate the following two photographs:


![.. ..gitbook/assets/zhuzi-2.jpg)

(.. . . . . . . . . . . . . . . . . . . . . . . . . . . . 

The former was bamboo and the second was several side trees。

Aristotle believes that seeds grow into large trees because they imply a potential and, when the environment is satisfied, they are likely to grow into a tree (see Shape to School 1049b). The difference between human beings is that they have no fixed potential, which is also consistent with the Confucian doctrine of “gentlemen are useless” (The Word for Government). Understanding the differences between the UNIX directory and the Windows directory is important for an in-depth understanding of the design and realization of the operating system。

We've all heard the story that Bambusoideae flowering means the death of a large piece of bamboo forest. This is because most of the seemingly rich bamboo forests are likely to end with only one single bamboo. These bamboo are grown from the same underground roots, and although they look multiple, they are a whole. And that's what springs after rain. No matter how far away they go, they're all good and bad. This is the UNIX directory - all directories in the system depend on root. Root is the starting point for all the directories. For example, CODESPAN_1 , CODESPAN_2 , CODESPAN_3 , they all go from root to root. In other words, if you delete __CODESPAN_4, then it's the same as deleting the entire system, and the catalogues on all devices will be deleted。

In contrast, each of the ordinary side trees grows independently. No matter how close they depend, they remain independent. Like Windows, walk trees are independent - CODESPAN_0, CODESPAN_1 , CODESPAN_2 : CODESPAN_3 , CODESPAN_4 , CODESPAN_5 . You format __CODESPAN_6_discs and do not affect __CODESPAN_7_disposed files. Even if you format ___CODESPAN_8_discussion in PE (perhaps not called __CODESPAN_9_discussion), it will not affect __CODESPAN_10_discretion。

In fact, Windows' "diskcards" do not exist at all, and experienced machine operators will find out that in the PE, CODESPAN_0 __ will become other discs such as __CODESPAN_1 __. Windows, which is in use, can also be distributed freely. Windows is the real judge of whether a partition is __CODESPAN_2_discs, and is judged by the GPT partition type UUID (e.g. my __CODESPAN_3_ partition type UUID is __CODESPAN_4_) and by the only ID (configuration is written in the EFI file) rather than by the disc. The discs are abstracted, and actually have no meaning. And that's why you can't see the root cause of CODESPAN_5_disc because there is no hard-coded ___CODESPAN_6_discmarking in the file system. Only when the system is really activated will Windows know who ___CODESPAN_7_disc and write it in the registration form. As for the distribution of the other discs, it was entirely by chance that the problem of __CODESPAN_8_discretion `E` _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ : _ _ _ _ _ _ : _  : : : : : : 

>** Thinking issues**
>
>Reading In-depth Analysis of Windows Operating Systems (7th ed.) (vol. 2) (97871156747, People ' s Post and Telecommunications) and other relevant literature, answer the question: How can Windows recognize __CODESPAN_0_discs, guided by traditional BIOS + MBR

# HOW TO UNDERSTAND UNIX MOUNT AND UNMOUNT

![.. ..gitbook/assets/jiajie.png]

When I was a kid, people in the garden knew that it was often necessary to cut a branch from the tree A, to stick it in the tree B, and wrap it up, and heal it and become one: For example, on UNIX, peaches can grow. This method is called “marriage”. In fact, the branch of tree A (file system) is mounted on tree B (the dow point, i.e. a mount point, ultimately depends on the root directory __CODESPAN_1 __)。


![..gitbook/assets/qiancha.png]

AND THOSE WHO KNOW ABOUT HORTICULTURE THINK THAT IT IS NO STRANGER TO THE WAY IN WHICH PLANTS ARE GROWN: TO BREAK DOWN A TREE'S NEW SIDE BRANCH INTO THE EARTH. A NEW SEEDLING WILL EMERGE FROM CAREFUL CARE FOR SOME TIME. IN FACT, THIS IS THE SAME THING AS THE PRINCIPLE OF “OFFLOADING”: TO REMOVE A DOCUMENT SYSTEM (E.G. ___ CODESPAN_0_) FROM THE FULL ROOT (__ ___ CODESPAN_1_) “BAKE” (OFFLOADING)。


# The difference between UNIX and Windows filenames

# # Invalid character #

Many files or filenames available in FreeBSD are not allowed in Windows (i.e. illegal characters). These are things you often encounter -- if you use Git to pull projects on Windows。

Here, only some of the penists have met:

- YOU CAN'T HAVE AN ENGLISH COLON

![.../.gitbook/assets/Windows1.png]

- CAN'T CALL IT CODESPAN



![..gitbook/assets/Windows2.png]

For more information, see Microsoft Official Document [Naming files, paths and naming spaces] (https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file)。

>** Skills**
>
> You can use the guit tool to pull [freebsd-doc] under Windows (https://github.com/freebsd/freebsd-doc) projects to try to be successful. I've reported Bug。
>
> [The Colonel in the file name of the security report of the FreeBSD doc is not common with Microsoft Windows.org/bugzilla/show_bug.cgi?id=26636)

# Case sensitive #

FreeBSD ZFS and UFS are both ** case sensitive** file systems. The MacOS HFC+ (default not supported), the APFS (default not supported) and the Windows FAT32 and NTFS file systems are all ** case insensitive**。

- Windows ** Case insensitive**

![..gitbook/assets/Windows3.png]

See, abbc and ABC can't coexist, the file system thinks it's the same file。

>** Skills**
>
The simplest way to judge the type of server to access the site is to see if the site path is case-sensitive: If the web site __CODESPAN_0 and __CODESPAN_1 is open and has the same content, then most of the site is driven by Windows。

- FreeBSD ** Case sensitive**

```sh
$ touch ABC
$ touch abc
$ ls
abc	ABC
```

See, abbc and ABC can coexist, and the file system thinks it's two different files。


References

- [Adjust Case sensitive] (https://learn.microsoft.com/zh-cn/windows/wsl/case-sensitation), Windows file systems support the use of attribute symbols for case-by-case setting

# Windows and Unix line break/back

Carriage Return, CR and Line Feed, LF are different concepts, all of which arise from the age of the tele typewriter (real TTY)。

- RETURN CR: MOVE THE CURSOR TO THE BEGINNING OF THE CURRENT LINE
- LINE BREAK LF: MOVE THE CURSOR STRAIGHT DOWN TO THE NEXT LINE。

YOU CAN SEE THAT IN THE EARLY DAYS THE TWO WERE INDEPENDENT, OTHERWISE THE CRLF WOULD CAUSE THE CURRENT LINE TO SINK。

The default line break for the Windows operating system is CRLF (i.e. \\r\n, 0x0D 0x0A,_CODESPAN_0__), while the default use of LF (i.e. \\n, 0x0A,_CODESPAN___) is used by Unix (early macOS is \\r, 0x0D)。

Of course, these symbols now appear at the end of each line of text (that is, each line exists)。

The two are incompatible, and if you place a Windows line break file below UNIX, this could result in an extra __CODESPAN_0_ character at the end of each line, which could cause an error of identification for some tools, and multi-line recognition for FreeBSD Port related files。

But two line breaks can be converted. Under FreeBSD, this can be done by Port __CODESPAN_0_, which contains two commands: __CODESPAN_1_1_(Windows line break to UNIX), __CODESPAN_2_(Unix line break to Windows). The basic usage is __CODESPAN_3_, and if the source file is not required, it can be __CODESPAN_4_ (multiple files converted at a time) directly. The line breaks of the file can be judged by command __CODESPAN_5:

- Use a normal Unix line break text file

```sh
$ file a.txt
a.txt: Unicode text, UTF-8 text
```

- Text file with Windows line breaks

```sh
$ file b.txt 
b.txt: Unicode text, UTF-8 text, with very long lines (314), with CRLF line terminators
```

# Windows and Unix character encoding

Since only __CODESPAN_0 and __CODESPAN_1_ are recognized by the computer, character encoding is a system of rules used to convert characters to numerical expressions. Characters can be visible text on the screen, or can be invisible control marks, such as line breaks (LF), returners (CRs) etc., which cover elements commonly found in text, such as numbers, Emoji emoticons, Han characters, Latin letters, etc. Encoding is the process by which the only digital identifier (usually the integer), code point (code point), is assigned to these characters。

For example, in the ASCII (American Standard Code for Information Exchange, United States Standard Code for Information Exchange, ISO/EEC 646) code, ___CODESPAN_0 (i.e. binary `0100 0001`) represents capital letters __CODESPAN_2_. The ASCII code only supports letters, numbers and common English dot symbols - a total of 128 characters。

And in the Unicode coding system, the code point for "you" is U+4F60. Under UTF-8 (8-bit Unicode Transport Format, 8-bit Unicode conversion format), it is encoded as a byte sequence ___CODESPAN_0_(bi-digit `11100100 10111101 10100000`_). The UTF-8 code covers a much larger range of characters than the GBK (national __CODESPAN_2_ standard __CODESPAN_3_extension `K`) and even Egyptian holy books - if you can now see the three characters "𓀀" "𓌊" on your screen, then you are probably using UTF-8 (if you use UTF-8 code but are unable to display these characters, it is likely that the fonts do not support these sets, rather than coding problems)。

How does the program identify the text code? Usually, some files begin with a specific byte sequence (i.e. BOM, byte order mark, byte tag). For example, the BOM of UTF-8 is __CODESPAN_0_. In practice, however, many text files do not have BOM, so the reading program needs to guess coding formats through context, which often leads to obfuscation. Although it is possible to guess coding through program analysis of text content (e.g. statistical character distribution or extraction), this method is not always reliable. The coding problem is inherently caused by the fact that the inter-system default coding is different or not clearly assigned。

Windows defaults to use GBK (if the system language is Chinese, it is a GB2312 superset), while Linux or UNIX uses UTF-8。

Windows 11 24H2

```powershell
PS C:\Users\ykla> chcp
活动代码页: 936 # 即 GBK
```

Ubuntu 24.04/FreeBSD

```sh
root@ykla:/home/ykla# locale charmap
UTF-8
```

Of these, the code for FreeBSD is set in [_other organisermain/usr.bin/login/login.conf] (https://github.com/freebsd/freebsd-src/blob/main/usr.bin/login/login.conf) this source file, which compiles the path __CODESPAN_0.conf)。

Naturally, you can also set the character code for Windows 10 and subsequent versions to UTF-8. This, of course, is not an effective solution beyond the additional coding problem。


References

- [Code pages] (https://learn.microsoft.com/en-us/globalization/encoding/code-pages), Microsoft Officially, 936 is GBK。

# Windows and Unix Time Settings

China uses a single Time Zone, the Eastern Zone, UTC+8, UTC (Coordinated Universal Time), almost the same time as GMT (Greenwich Mean Time, Greenwich Time). UTC is based (not entirely consistent) on the length of seconds at international atoms: when Cs frequency ΔνCs, i.e. cesium 133, the non-disturbing substrate super-precision jump frequency, defined by a fixed value of 9,192,631,770 in units Hz, s-1 - various amendments were made to international atoms。

Those with Windows and Unix dual system installation experience will find that Windows and Unix are always eight hours short. On modern computers (usually on the main panel) there is a RTC (Real-time clock chip, real-time clock chip) chip powered by button batteries, which is used to maintain the timing of system failure。

THE COMPUTER OPERATING SYSTEM WILL READ RTC TIME WHEN IT STARTS. RTC TIME DOES NOT INDICATE TIME ZONE。

Windows will read the results of the RTC directly as the default local time, i.e., Local Time (local time, local sun running time); Unix will consider the RTC data as UTC time: So you'll find a two-system rewind in time for eight hours。

For example, if the RTC time is “12 noon during the day of June 6th, 2025 (i.e. UTC+8), then Windows is also “12 noon during the day of June 6th, 2025” (i.e. UTC+8), but under Unix, the time becomes “4:00 during the day of June 6th, 2025” (i.e. UTC+8-8). Because we use UTC+8, the difference is eight hours。

FOR MODERN COMPUTER NETWORKS, TIME IS OF THE ESSENCE, SO WE CAN DO A LITTLE EXPERIMENT, SLOW THE TIME DOWN FOR FIVE MINUTES, TURN ON THE BROWSER, AND YOU'LL FIND THAT MOST WEBSITES CAN'T OPEN (HTTPS)。

THE TIME ZONE IN THE COMPUTER IS REGULATED BY THE IANA TIME ZONE DATABASE, WHICH HAS A LONG HISTORY。

IN ITS TWENTY-EIGHTH YEAR (1939), THE GOVERNMENT OF THE REPUBLIC OF CHINA DIVIDED CHINA INTO FIVE TIME ZONES, DIVIDED INTO HARBIN (-CODESPAN_0), SHANGHAI (-CODESPAN_1), CHONGQING (-CODESPAN_2 ), URUMUZI (-CODESPAN_3 ) AND KASH (-CODESPAN_4 __)。

We know that Xinjiang is the Eastern Six Region (although Beijing time is used nationally). Geographically, Xinjiang is actually two hours away from Beijing time. In fact, if the sun comes out at 8:00 in East Eight, Xinjiang comes out at 10:00。

In the Time Zone database 2025b ___ CODESPAN_0, __ CODESPAN_1 and __ CODESPAN_2 __ are equal to Beijing time. ___ CODESPAN_3_ and __ CODESPAN_4_ are both __ CODESPAN_5_ Eastern Six Time。

In FreeBSD, Beijing time is also ___ CODESPAN_0_ (East Eight Region). Some so-called CODESPAN_1 — which is not only an act of disrespect for international standards and norms but also has serious consequences, such as the return of time to the UTC — would be in vain。

Note**
>
> BEIJING (116° EAST) DOES NOT EXACTLY EQUAL UTC+8. THE BEIJING TIME WE'RE TALKING ABOUT IS NOT BEIJING, BUT 120 DEGREES EAST。


>** Skills**
>
>China also had summer days (slowing the watch a few hours in the summer because it was early)。


>** Thinking issues**
>
What time zone does outer space use? Why

References

- [Definition of seconds] (https://www.nim.ac.cn/520/node/4.html)
- [Time Zone Database] (https://www.iana.org/time-zones)
